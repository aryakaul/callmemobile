#!/usr/bin/env python3

import argparse
import subprocess
import sys
import os

from multiprocessing import Pool
from loguru import logger
from Bio import SeqIO

import modules.mobileelementfinder as mefinderfuncs
import modules.IntegronFinder as integronfinderfuncs
import modules.PlasmidFinder as plasmidfinderfuncs
import modules.mob_suite as mobsuitefuncs


def get_version():
    version = open(os.path.join(repo_path, "VERSION"), "r").readline().strip()
    return version


def parse_arguments(version):
    parser = argparse.ArgumentParser()
    parser.add_argument(
        "--input",
        "-i",
        help="[REQUIRED] Path to the input fasta reference file.",
        type=os.path.abspath,
        required=True,
    )
    parser.add_argument(
        "--bed",
        "-b",
        help="[REQUIRED] Path to the input bed file to query for putative\
 mobility",
        type=os.path.abspath,
        required=True,
    )
    parser.add_argument(
        "--output",
        "-o",
        help="Directory for the output. Default is ./maybemobile_out/",
        type=os.path.abspath,
        default="./maybemobile_out/",
        required=False,
    )
    parser.add_argument(
        "--threads",
        "-t",
        help="Number of threads to use. Default is all available.",
        type=int,
        default=len(os.sched_getaffinity(0)),
        required=False,
    )
    parser.add_argument(
        "--version",
        "-V",
        help="Print program version",
        action="version",
        version=f"mamo {version}",
    )
    parser.add_argument(
        "--mobrecon_outdir",
        help="Path to the output directory of mob_recon",
        type=os.path.abspath,
        required=False,
    )
    return parser.parse_args()


def run_classify_mobileelementfinder(input_fasta, input_bed):
    mgeout = mefinderfuncs.run_mobileelementfinder(
        input_fasta, output_path, threads
    )
    bedmgeout = mefinderfuncs.bedformat_mobileelementfinder(
        mgeout, description_to_id
    )
    return mefinderfuncs.classify_mobileelementfinder(input_bed, bedmgeout)


def run_classify_plasmidfinder(input_fasta, input_bed):
    pfinderout = plasmidfinderfuncs.run_plasmidfinder(input_fasta, output_path)
    bedpfinderout = plasmidfinderfuncs.bedformat_plasmidfinder(
        pfinderout, description_to_id
    )
    return plasmidfinderfuncs.classify_plasmidfinder(
        input_fasta, input_bed, bedpfinderout
    )


def read_classify_mobrecon(input_fasta, mobrecondir, input_bed):
    bedmobrecon = bedformat_mobrecon(mobrecondir)
    classify_mobrecon(input_fasta, input_bed, bedpfinderout)


def run_classify_integronfinder(input_fasta, input_bed):
    ifinderout = integronfinderfuncs.run_integronfinder(
        input_fasta, output_path, threads
    )
    if not ifinderout:
        logger.info("No integrons found. Moving on.")
        return ""
    else:
        bedifinder = integronfinderfuncs.bedformat_integronfinder(ifinderout)
        return integronfinderfuncs.classify_integronfinder(
            input_bed, bedifinder
        )


def check_input(input_fasta, input_bed):
    fasta_sequences = SeqIO.parse(open(input_fasta), "fasta")
    global description_to_id
    description_to_id = {}
    for i in fasta_sequences:
        description_to_id[i.description] = i.id
    logger.debug(f"Fasta header to identifier is: {description_to_id}")


def search_classified_results(args):
    inputline, tooloutput_dict = args
    result = []
    for toolname in tooloutput_dict:
        tooloutput = tooloutput_dict[toolname]
        with open(tooloutput) as f:
            for tool_bedline in f:
                if "\t".join(inputline.strip().split()[:3]) in tool_bedline:
                    result.append(
                        (inputline.strip(), toolname, tool_bedline.strip())
                    )
    return result


def merge_results(inputbed, tooloutput_dict):
    logger.info(f"Merging results...")
    with open(inputbed) as ib:
        inputlines = ib.readlines()
    pool = Pool()
    results = pool.map(
        search_classified_results,
        [(line, tooloutput_dict) for line in inputlines],
    )
    pool.close()
    pool.join()
    result_dict = {}
    for line in inputlines:
        key = line.strip()
        result_dict[key] = {}

    for result in results:
        for key, name, value in result:
            if name not in result_dict[key]:
                result_dict[key][name] = []
            result_dict[key][name].append(value)
    # for value in result_dict:
    # if "mobileelementfinder" not in result_dict[value]:
    # print(value)
    # else:
    # print(value)
    # print(result_dict[value])
    # print(result_dict[value]["mobileelementfinder"])
    # print("")
    return result_dict


def output_result(result_dict):
    mamoout_unsorted = os.path.join(output_path, "mamoout.unsorted.bed")
    mamoout_sorted = os.path.join(output_path, "mamoout.sorted.bed")
    with open(mamoout_unsorted, "w") as f:
        f.write(
            "\t".join(
                [
                    "Contig",
                    "Start",
                    "End",
                    "Annotation",
                    "mobileelementfinder" + "\n",
                ]
            )
        )
        for value in result_dict:
            if "mobileelementfinder" not in result_dict[value]:
                f.write("\t".join([value, "no-me" + "\n"]))
            else:
                mobileelements = result_dict[value]["mobileelementfinder"]
                me_out = []
                for me in mobileelements:
                    me_append = me.split("\t")[3].split("|")[1]
                    me_out.append(me_append)
                f.write("\t".join([value, "|".join(me_out) + "\n"]))
                # mobileelement=result_dict[value]['mobileelementfinder'].split('\t')[3]
                # sandwiched = False
                # print(mobileelement)
                # if mobileelement.split('|')[0][-1] == ' ': sandwiched=True
                # if sandwiched:
                # f.write(
                # "\t".join(
                # [
                # value,
                # "sandwiched-" + mobileelement.split('|')[1] + "\n",
                # ]
                # )
                # )
                # else:
                # f.write(
                # "\t".join(
                # [
                # value,
                # "within-" + mobileelement.split('|')[1] + "\n",
                # ]
                # )
                # )

    output = subprocess.run(
        ["sort-bed", f"{mamoout_unsorted}", ">", f"{mamoout_sorted}"],
        capture_output=True,
    )


def run_tools(input_fasta, input_bed):
    logger.info(f"Input fasta: {input_fasta}")
    logger.info(f"Input bed: {input_bed}")

    # run mobileelementfinder
    mefinder_outbed = run_classify_mobileelementfinder(input_fasta, input_bed)

    # run integron_finder
    # integron_outbed = run_classify_integronfinder(input_fasta, input_bed)

    # run plasmidfinder.py
    # pfinder_outbed = run_classify_plasmidfinder(input_fasta, input_bed)

    # run mobrecon
    # run_classify_mobrecon(input_fasta, input_bed)
    result_dict = merge_results(
        input_bed,
        {
            "mobileelementfinder": mefinder_outbed,
            # "IntegronFinder": integron_outbed,
            # "PlasmidFinder": pfinder_outbed,
        },
    )
    output_result(result_dict)


def main():
    # set global vars
    global pipeline
    global repo_path
    global output_path
    global threads
    pipeline = "MAMO"

    # set paths
    repo_path = os.path.dirname(os.path.realpath(__file__))

    # parse args
    args = parse_arguments(get_version())

    output_path = args.output
    threads = args.threads

    # check input
    check_input(args.input, args.bed)

    # run all tools
    run_tools(args.input, args.bed)


if __name__ == "__main__":
    main()
