#!/usr/bin/env python3

import argparse
import subprocess
import sys
import os

from multiprocessing import Pool
from loguru import logger
from Bio import SeqIO

import modules.mobileelementfinder as mefinderfuncs
import modules.IntegronFinder as integronfinderfuncs
import modules.PlasmidFinder as plasmidfinderfuncs
import modules.mob_suite as mobsuitefuncs


def get_version():
    version = open(os.path.join(repo_path, "VERSION"), "r").readline().strip()
    return version


def parse_arguments(version):
    parser = argparse.ArgumentParser()
    parser.add_argument(
        "--input",
        "-i",
        help="[REQUIRED] Path to the input fasta reference file.",
        type=os.path.abspath,
        required=True,
    )
    parser.add_argument(
        "--bed",
        "-b",
        help="[REQUIRED] Path to the input bed file to query for putative\
 mobility",
        type=os.path.abspath,
        required=True,
    )
    parser.add_argument(
        "--output",
        "-o",
        help="Directory for the output. Default is ./maybemobile_out/",
        type=os.path.abspath,
        default="./maybemobile_out/",
        required=False,
    )
    parser.add_argument(
        "--threads",
        "-t",
        help="Number of threads to use. Default is all available.",
        type=int,
        default=len(os.sched_getaffinity(0)),
        required=False,
    )
    parser.add_argument(
        "--version",
        "-V",
        help="Print program version",
        action="version",
        version=f"mamo {version}",
    )
    parser.add_argument(
        "--mobrecon_outdir",
        help="Path to the output directory of mob_recon",
        type=os.path.abspath,
        required=False,
    )
    parser.add_argument(
        "--mobileelementfinder_outdir",
        help="Path to the output directory of mobileelementfinder",
        type=os.path.abspath,
        required=False,
    )
    return parser.parse_args()


def run_classify_mobileelementfinder(input_fasta, input_bed):
    mgeout = mefinderfuncs.run_mobileelementfinder(
        input_fasta, output_path, threads
    )
    bedmgeout = mefinderfuncs.bedformat_mobileelementfinder(
        mgeout, description_to_id
    )
    return mefinderfuncs.classify_mobileelementfinder(input_bed, bedmgeout)


def run_classify_plasmidfinder(input_fasta, input_bed):
    pfinderout = plasmidfinderfuncs.run_plasmidfinder(input_fasta, output_path)
    bedpfinderout = plasmidfinderfuncs.bedformat_plasmidfinder(
        pfinderout, description_to_id
    )
    return plasmidfinderfuncs.classify_plasmidfinder(
        input_fasta, input_bed, bedpfinderout
    )


def run_classify_integronfinder(input_fasta, input_bed):
    ifinderout = integronfinderfuncs.run_integronfinder(
        input_fasta, output_path, threads
    )
    with open(ifinderout) as f:
        for line in f:
            if "# No Integron found" in line:
                logger.info("No integrons found")
                return ifinderout
    bedifinder = integronfinderfuncs.bedformat_integronfinder(ifinderout)
    return integronfinderfuncs.classify_integronfinder(input_bed, bedifinder)


def check_input(input_fasta, input_bed):
    fasta_sequences = SeqIO.parse(open(input_fasta), "fasta")
    global description_to_id
    # define a dictionary of chromosome keys and values
    description_to_id = {}
    for i in fasta_sequences:
        description_to_id[i.description] = i.id
    logger.debug(f"Fasta header to identifier is: {description_to_id}")
    output_bed = os.path.join(
        os.path.dirname(input_bed),
        os.path.basename(input_bed) + "-chromosomeid",
    )

    exit = False
    # open the input BED file for reading
    with open(input_bed, "r") as input_file:
        # open the output BED file for writing
        with open(output_bed, "w") as output_file:
            # loop through each line in the input BED file
            for line in input_file:
                # split the line into columns
                fields = line.strip().split("\t")
                if len(fields) != 4:
                    print(fields)
                    logger.error(
                        f"Number of columns is {len(fields)}! This is not 4! Please make it 4 columns!"
                    )
                    exit = True

                # check if the chromosome in the line matches a key in the dictionary
                if fields[0] in description_to_id:
                    exit = True
                    logger.error(
                        f"{fields[0]} found in bed file! Please use {description_to_id[fields[0]]} instead! Reformatted bedfile outputted here {output_bed}. Please rerun mamo with that bed file instead!"
                    )
                    # if there is a match, replace the chromosome value with the dictionary value
                    fields[0] = description_to_id[fields[0]]

                # write the updated line to the output BED file
                output_file.write("\t".join(fields) + "\n")
    if exit:
        sys.exit(2)
    else:
        os.remove(output_bed)


def search_classified_results(args):
    inputline, tooloutput_dict = args
    result = []
    for toolname in tooloutput_dict:
        tooloutput = tooloutput_dict[toolname]
        with open(tooloutput) as f:
            for tool_bedline in f:
                if "\t".join(inputline.strip().split()[:3]) in tool_bedline:
                    result.append(
                        (inputline.strip(), toolname, tool_bedline.strip())
                    )
    return result


def merge_results(inputbed, tooloutput_dict):
    logger.info(f"Merging results...")
    with open(inputbed) as ib:
        inputlines = ib.readlines()
    pool = Pool()
    results = pool.map(
        search_classified_results,
        [(line, tooloutput_dict) for line in inputlines],
    )
    pool.close()
    pool.join()
    result_dict = {}
    for line in inputlines:
        key = line.strip()
        result_dict[key] = {}

    for result in results:
        for key, name, value in result:
            if name not in result_dict[key]:
                result_dict[key][name] = []
            result_dict[key][name].append(value)
    # print(result_dict)
    return result_dict


def output_result(result_dict, tooldict):
    mamoout_unsorted = os.path.join(output_path, "mamoout.unsorted.bed")
    mamoout_sorted = os.path.join(output_path, "mamoout.sorted.bed")
    toolsran = list(tooldict.keys())
    with open(mamoout_unsorted, "w") as f:
        f.write(
            "\t".join(
                [
                    "#Contig",
                    "Start",
                    "End",
                    "Annotation",
                ]
                + toolsran
            )
            + "\n"
        )

        for value in result_dict:
            line_append = []
            if "mobileelementfinder" in toolsran:
                if "mobileelementfinder" not in result_dict[value]:
                    line_append.append("no-me")
                else:
                    mobileelements = result_dict[value]["mobileelementfinder"]
                    me_out = []
                    for me in mobileelements:
                        me_append = me.split("\t")[3].split("|")[1]
                        me_out.append(me_append)
                    line_append.append("|".join(me_out))
            if "IntegronFinder" in toolsran:
                if "IntegronFinder" not in result_dict[value]:
                    line_append.append("no-integron")
                else:
                    if_out = result_dict[value]["IntegronFinder"][0].split(
                        "|"
                    )[1]
                    line_append.append(if_out)
            if "PlasmidFinder" in toolsran:
                if "PlasmidFinder" not in result_dict[value]:
                    line_append.append("no-plasmid")
                else:
                    pfinder_out = result_dict[value]["PlasmidFinder"][0].split(
                        "\t"
                    )[4]
                    line_append.append(pfinder_out)
            if "mob_recon" in toolsran:
                if "mob_recon" not in result_dict[value]:
                    line_append.append("no-plasmid")
                else:
                    mobrecon_out = result_dict[value]["mob_recon"][0].split(
                        "\t"
                    )[4]
                    line_append.append(mobrecon_out)
            line_append[-1] = line_append[-1] + "\n"
            f.write("\t".join([value] + line_append))

    with open(mamoout_sorted, "w") as outfile:
        output = subprocess.run(
            ["sort-bed", f"{mamoout_unsorted}"],
            stdout=outfile,
        )
    logger.success(
        f"Mamo completed successfully! Output here: {mamoout_sorted}"
    )


def run_tools(input_fasta, input_bed):
    logger.info(f"Input fasta: {input_fasta}")
    logger.info(f"Input bed: {input_bed}")

    # run mobileelementfinder
    mefinder_outbed = run_classify_mobileelementfinder(input_fasta, input_bed)

    # run integron_finder
    integron_outbed = run_classify_integronfinder(input_fasta, input_bed)

    # run plasmidfinder.py
    pfinder_outbed = run_classify_plasmidfinder(input_fasta, input_bed)

    tool_dict = {
        "mobileelementfinder": mefinder_outbed,
        "IntegronFinder": integron_outbed,
        "PlasmidFinder": pfinder_outbed,
    }

    # classify mobrecon
    if args.mobrecon_outdir:
        mobrecon_outbed = mobsuitefuncs.classify_mobrecon(
            input_fasta, input_bed, args.mobrecon_outdir, args.output
        )
        tool_dict["mob_recon"] = mobrecon_outbed

    result_dict = merge_results(input_bed, tool_dict)
    # print(result_dict)
    output_result(result_dict, tool_dict)


def main():
    # set global vars
    global pipeline
    global repo_path
    global output_path
    global threads
    global args
    pipeline = "MAMO"

    # set paths
    repo_path = os.path.dirname(os.path.realpath(__file__))

    # parse args
    args = parse_arguments(get_version())

    output_path = args.output
    threads = args.threads

    # check input
    check_input(args.input, args.bed)

    # run all tools
    run_tools(args.input, args.bed)


if __name__ == "__main__":
    main()
