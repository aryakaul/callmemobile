#!/usr/bin/env python3

import argparse
import subprocess

# import multiprocessing
import os

# import glob
from loguru import logger
import sys
from Bio import SeqIO

# import pandas as pd


def get_version():
    version = open(os.path.join(repo_path, "VERSION"), "r").readline().strip()
    return version


def parse_arguments(version):
    parser = argparse.ArgumentParser()
    parser.add_argument(
        "--input",
        "-i",
        help="[REQUIRED] Path to the input fasta reference file.",
        type=os.path.abspath,
        required=True,
    )
    parser.add_argument(
        "--bed",
        "-b",
        help="[REQUIRED] Path to the input bed file to query for putative\
 mobility",
        type=os.path.abspath,
        required=True,
    )
    parser.add_argument(
        "--output",
        "-o",
        help="Directory for the output. Default is ./maybemobile_out/",
        type=os.path.abspath,
        default="./maybemobile_out/",
        required=False,
    )
    parser.add_argument(
        "--threads",
        "-t",
        help="Number of threads to use. Default is all available.",
        type=int,
        default=len(os.sched_getaffinity(0)),
        required=False,
    )
    parser.add_argument(
        "--version",
        "-V",
        help="Print program version",
        action="version",
        version=f"mamo {version}",
        # version="hi",
    )
    return parser.parse_args()


def run_mobileelementfinder(input_fasta):
    mefinder_output = os.path.join(
        "/".join([output_path, "mobileElementFinder_out"])
    )
    if not os.path.exists(mefinder_output):
        os.makedirs(mefinder_output)
        logger.info(
            f"Created {mefinder_output} for output of mobileElementFinder"
        )
    mefinder_output = os.path.join("/".join([mefinder_output, "out"]))
    output = subprocess.run(
        [
            "mefinder",
            "find",
            "--contig",
            f"{input_fasta}",
            "--threads",
            f"{threads}",
            f"{mefinder_output}",
        ],
        capture_output=True,
    )
    if output.returncode != 0:
        logger.error("Error in mobileelementfinder!")
        logger.error(output.stdout.decode())
        logger.error(output.stderr.decode())
        sys.exit(2)
    else:
        logger.debug(output.stdout.decode())
        # logger.debug(output.stderr.decode())
        logger.success("Completed mobileelementfinder")
    return "".join([mefinder_output, ".csv"])


def run_integronfinder(input_fasta):
    integronfinder_output = os.path.join(
        "/".join([output_path, "integronfinder_out"])
    )
    if not os.path.exists(integronfinder_output):
        os.makedirs(integronfinder_output)
        logger.info(
            f"Created {integronfinder_output} for output of Integron-Finder"
        )
    input_fasta_basename = os.path.basename(input_fasta)
    input_fasta_basename = os.path.splitext(input_fasta_basename)[0]
    output = subprocess.run(
        [
            "integron_finder",
            "--local-max",
            "--cpu",
            f"{threads}",
            "--circ",
            "--outdir",
            f"{integronfinder_output}",
            f"{input_fasta}",
        ],
        capture_output=True,
    )
    if output.returncode != 0:
        logger.error("Error in IntegronFinder!")
        logger.error(output.stdout.decode())
        logger.error(output.stderr.decode())
        sys.exit(2)
    else:
        logger.debug(output.stdout.decode())
        # logger.debug(output.stderr.decode())
        logger.success("Completed IntegronFinder")
    integronfinder_output_integrons = os.path.join(
        "/".join(
            [
                integronfinder_output,
                "Results_Integron_Finder_" + input_fasta_basename,
                input_fasta_basename + ".integrons",
            ]
        )
    )
    if os.path.exists(integronfinder_output_integrons):
        return integronfinder_output_integrons
    else:
        return ""


def run_mobrecon(ifasta):
    mobrecon_output = os.path.join("/".join([output_path, "mobrecon_out"]))
    if not os.path.exists(mobrecon_output):
        os.makedirs(mobrecon_output)
        logger.info(f"Created {mobrecon_output} for output of mob_recon")
    output = subprocess.run(
        [
            "mob_recon",
            "--infile",
            f"{ifasta}",
            "--num_threads",
            f"{threads}",
            "--outdir",
            f"{mobrecon_output}",
            "--force",
        ],
        capture_output=True,
    )
    if output.returncode != 0:
        logger.error("Error in mob_recon!")
        logger.error(output.stdout.decode())
        logger.error(output.stderr.decode())
        sys.exit(2)
    else:
        logger.debug(output.stdout.decode())
        # logger.debug(output.stderr.decode())
        logger.success("Completed mob_recon")
    return os.path.join("/".join([mobrecon_output, "contig_report.txt"]))


def bedformat_integronfinder(ifinder_out):
    ifinder_outputbed = os.path.dirname(ifinder_out)
    ifinder_outputbed = os.path.join(
        "/".join([ifinder_outputbed, "integronfinder_out.sorted.bed"])
    )
    output = subprocess.run(
        [
            f"grep -v '^#' {ifinder_out} \
            | sed 1d \
            | cut -f2,4,5 \
            | sort-bed -",
        ],
        capture_output=True,
        shell=True,
    )
    if output.returncode != 0:
        logger.error("Error in formatting Integron Finder output as bedfile!")
        logger.error(output.stdout.decode())
        logger.error(output.stderr.decode())
        sys.exit(2)
    else:
        with open(f"{ifinder_outputbed}", "w") as f:
            f.write(str(output.stdout.decode()))
        # logger.debug(output.stderr.decode())
        logger.success(
            f"Completed reformatting Integron Finder output to {ifinder_outputbed}"
        )
        return ifinder_outputbed


def run_plasmidfinder(input_fasta):
    plasmidfinder_output = os.path.join(
        "/".join([output_path, "plasmidfinder_out"])
    )
    if not os.path.exists(plasmidfinder_output):
        os.makedirs(plasmidfinder_output)
        logger.info(
            f"Created {plasmidfinder_output} for output of plasmidfinder"
        )
    output = subprocess.run(
        [
            "plasmidfinder.py",
            "-i",
            f"{input_fasta}",
            "-o",
            f"{plasmidfinder_output}",
            "-x",
        ],
        capture_output=True,
    )
    if output.returncode != 0:
        logger.error("Error in plasmidfinder!")
        logger.error(output.stdout.decode())
        logger.error(output.stderr.decode())
        sys.exit(2)
    else:
        logger.debug(output.stdout.decode())
        # logger.debug(output.stderr.decode())
        logger.success("Completed plasmidfinder")
    return os.path.join("/".join([plasmidfinder_output, "results_tab.tsv"]))


def bedformat_mobileelementfinder(mge_outputcsv):
    mge_outputbed = os.path.dirname(mge_outputcsv)
    mge_outputbed = os.path.join(
        "/".join([mge_outputbed, "mge_out.sorted.bed"])
    )
    output = subprocess.run(
        [
            f"grep -v '^#' {mge_outputcsv} \
            | csvtk cut -f contig,start,end,name,type -T \
            | sed 1d"
        ],
        capture_output=True,
        shell=True,
    )
    if output.returncode != 0:
        logger.error("Error in formatting mge output as bedfile!")
        logger.error(output.stdout.decode())
        logger.error(output.stderr.decode())
        sys.exit(2)
    else:
        with open(f"{mge_outputbed}.unsorted", "w") as f:
            for lines in output.stdout.decode().split("\n"):
                linelist = lines.split("\t")
                if len(linelist) == 0:
                    continue
                mge_id = linelist[0]
                if mge_id in description_to_id:
                    f.write(
                        description_to_id[mge_id]
                        + "\t"
                        + "\t".join(linelist[1:])
                        + "\n"
                    )
                else:
                    f.write("\t".join(linelist) + "\n")
        output = subprocess.run(
            [f"sort-bed {mge_outputbed}.unsorted > {mge_outputbed}"],
            check=True,
            shell=True,
        )
        logger.success(f"Completed reformatting mge output to {mge_outputbed}")
        return mge_outputbed


def bedformat_plasmidfinder(pfinderout):
    pfinder_outputbed = os.path.dirname(pfinderout)
    pfinder_outputbed = os.path.join(
        "/".join([pfinder_outputbed, "plasmidfinder_out.sorted.bed"])
    )
    output = subprocess.run(
        [
            f"csvtk cut -t -f Contig,'Position in contig',Plasmid,Note {pfinderout} \
            | sed 1d"
        ],
        capture_output=True,
        shell=True,
    )
    if output.returncode != 0:
        logger.error("Error in formatting plasmidfinder output as bedfile!")
        logger.error(output.stdout.decode())
        logger.error(output.stderr.decode())
        sys.exit(2)
    else:
        with open(f"{pfinder_outputbed}.unsorted", "w") as f:
            for lines in output.stdout.decode().split("\n"):
                linelist = lines.split("\t")
                if len(linelist) <= 1:
                    continue
                pfinder_id = linelist[0]
                print(linelist[1])
                pfinder_coords = linelist[1].split("..")
                if pfinder_id in description_to_id:
                    f.write(
                        description_to_id[pfinder_id]
                        + "\t"
                        + "\t".join(pfinder_coords)
                        + "\t"
                        + "\t".join(linelist[2:])
                        + "\n"
                    )
                else:
                    f.write(
                        pfinder_id
                        + "\t"
                        + "\t".join(pfinder_coords)
                        + "\t"
                        + "\t".join(linelist[2:])
                        + "\n"
                    )
        output = subprocess.run(
            [f"sort-bed {pfinder_outputbed}.unsorted > {pfinder_outputbed}"],
            check=True,
            shell=True,
        )
        logger.success(
            f"Completed reformatting plasmidfinder output to {pfinder_outputbed}"
        )
        return pfinder_outputbed


def classify_mobileelementfinder(inputbed, bedmge):
    maxdist = 20000

    bed = os.path.dirname(bedmge)
    output_bed = os.path.join(
        "/".join([bed, "input-mge_out-intersect.sorted.bed"])
    )
    output = subprocess.run(
        [
            f"closest-features --dist --closest {inputbed} {bedmge} \
            | awk -F'\\t' '{{split($7, a, \"|\");if(sqrt(a[2]^2) < {maxdist}){{print $0}}}}'"
        ],
        capture_output=True,
        shell=True,
    )
    if output.returncode != 0:
        logger.error("Error in classifying mge's results! closest-features")
        logger.error(output.stdout.decode())
        logger.error(output.stderr.decode())
        sys.exit(2)
    else:
        with open(f"{output_bed}", "w") as f:
            f.write(str(output.stdout.decode()))
        logger.debug(output.stderr.decode())
    logger.success("Completed classifying mge output")
    return output_bed


def classify_integronfinder(input_bed, bedifinder):
    bed = os.path.dirname(bedifinder)
    output_bed = os.path.join(
        "/".join([bed, "input-ifinder_out-intersect.sorted.bed"])
    )
    output = subprocess.run(
        [f"bedops -e 90% {input_bed} {bedifinder}"],
        capture_output=True,
        shell=True,
    )
    if output.returncode != 0:
        logger.error(
            "Error in classifying Integron Finder's results! bedops -e"
        )
        logger.error(output.stdout.decode())
        logger.error(output.stderr.decode())
        sys.exit(2)
    else:
        with open(f"{output_bed}", "w") as f:
            f.write(str(output.stdout.decode()))
        logger.debug(output.stderr.decode())
    logger.success("Completed classifying Integron Finder output")
    return output_bed


def classify_plasmidfinder(inputfasta, inputbed, bedpfinder):
    max_plasmidlen = 200000
    maxdist = 20000

    bed = os.path.dirname(bedpfinder)
    output_bed = os.path.join(
        "/".join([bed, "input-pfinder_out-intersect.sorted.bed"])
    )

    for contig in SeqIO.parse(inputfasta, "fasta"):
        contig_len = len(contig)
        contig_id = contig.id
        if contig_len > max_plasmidlen:
            logger.info(
                f"{contig_id} is {contig_len:,} bp which is greater than max \
plasmid len: {max_plasmidlen:,} bp."
            )
            logger.info(f"treating {contig_id} as a chromosome.")
            output = subprocess.run(
                [
                    f"closest-features --chrom {contig_id} --dist --closest {inputbed} {bedpfinder} \
                    | awk -F'\\t' '{{split($7, a, \"|\");if(sqrt(a[2]^2) < {maxdist}){{print $0}}}}'"
                ],
                capture_output=True,
                shell=True,
            )
            if output.returncode != 0:
                logger.error(
                    f"Error in classifying PlasmidFinder's results! closest-features {contig_id}"
                )
                logger.error(output.stdout.decode())
                logger.error(output.stderr.decode())
                sys.exit(2)
            else:
                with open(f"{output_bed}", "w") as f:
                    f.write(str(output.stdout.decode()))
                # logger.debug(output.stderr.decode())
        else:
            logger.info(f"{contig_id} is {contig_len:,} bp")
            output = subprocess.run(
                [
                    f'grep -q "{contig_id}" "{bedpfinder}" && grep "{contig_id}" "{inputbed}"'
                ],
                capture_output=True,
                shell=True,
            )
            if output.returncode != 0:
                logger.error(
                    f"Error in classifying PlasmidFinder's results! grep {contig_id}"
                )
                logger.error(output.stdout.decode())
                logger.error(output.stderr.decode())
                sys.exit(2)
            else:
                with open(f"{output_bed}", "a") as f:
                    f.write(str(output.stdout.decode()))
    logger.success("Completed classifying PlasmidFinder output")
    return output_bed


def run_classify_mobileelementfinder(input_fasta, input_bed):
    mgeout = run_mobileelementfinder(input_fasta)
    bedmgeout = bedformat_mobileelementfinder(mgeout)
    classify_mobileelementfinder(input_bed, bedmgeout)


def run_classify_plasmidfinder(input_fasta, input_bed):
    pfinderout = run_plasmidfinder(input_fasta)
    bedpfinderout = bedformat_plasmidfinder(pfinderout)
    classify_plasmidfinder(input_fasta, input_bed, bedpfinderout)


def run_classify_mobrecon(input_fasta, input_bed):
    mobreconout = run_mobrecon(input_fasta)
    # bedpfinderout = bedformat_plasmidfinder(pfinderout)
    # classify_plasmidfinder(input_fasta, input_bed, bedpfinderout)


def run_classify_integronfinder(input_fasta, input_bed):
    ifinderout = run_integronfinder(input_fasta)
    if not ifinderout:
        logger.info("No integrons found. Moving on.")
    else:
        bedifinder = bedformat_integronfinder(ifinderout)
        classify_integronfinder(input_bed, bedifinder)


def check_input(input_fasta, input_bed):
    fasta_sequences = SeqIO.parse(open(input_fasta), "fasta")
    global description_to_id
    description_to_id = {}
    for i in fasta_sequences:
        description_to_id[i.description] = i.id
    # print(description_to_id)


def run_tools(input_fasta, input_bed):
    logger.info(f"Input fasta: {input_fasta}")
    logger.info(f"Input bed: {input_bed}")

    # run mobileelementfinder
    run_classify_mobileelementfinder(input_fasta, input_bed)

    # run integron_finder
    run_classify_integronfinder(input_fasta, input_bed)

    # run plasmidfinder.py
    run_classify_plasmidfinder(input_fasta, input_bed)

    # run mobrecon
    # run_classify_mobrecon(input_fasta, input_bed)


def main():
    # set global vars
    global pipeline
    global repo_path
    global output_path
    global threads
    pipeline = "MAMO"

    # set paths
    repo_path = os.path.dirname(os.path.realpath(__file__))

    # parse args
    args = parse_arguments(get_version())

    output_path = args.output
    threads = args.threads

    # check input
    check_input(args.input, args.bed)

    # run all tools
    run_tools(args.input, args.bed)


if __name__ == "__main__":
    main()
